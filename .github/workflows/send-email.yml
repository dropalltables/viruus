name: Send Blog Post Email

on:
  push:
    branches:
      - main
    paths:
      - 'content/blog/**'

jobs:
  send-email:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect new files
      
      - name: Install pandoc
        run: sudo apt-get update && sudo apt-get install -y pandoc
      
      - name: Send email for new blog posts
        env:
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RESEND_SEGMENT_ID: ${{ secrets.RESEND_SEGMENT_ID }}
          RESEND_TEST_SEGMENT_ID: ${{ secrets.RESEND_TEST_SEGMENT_ID }}
        run: |
          #!/bin/bash
          set -e
          
          echo "Checking for new or modified blog posts..."
          echo ""
          
          # Check if commit message contains [[REPUBLISH file1.md file2.md ...]] (case-sensitive)
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          REPUBLISH_FILES=""
          if echo "$COMMIT_MESSAGE" | grep -q '\[\[REPUBLISH [^]]*\]\]'; then
            REPUBLISH_FILES=$(echo "$COMMIT_MESSAGE" | grep -o '\[\[REPUBLISH [^]]*\]\]' | sed 's/\[\[REPUBLISH //' | sed 's/\]\]//')
            echo "Found [[REPUBLISH $REPUBLISH_FILES]] in commit message - will republish those posts"
          fi
          echo ""
          
          # Get list of new or modified files in content/blog/
          CHANGED_FILES=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD | grep '^content/blog/.*\.md$' | grep -v '_index.md' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No new or modified blog posts found."
            exit 0
          fi
          
          echo "Found changed blog post(s):"
          echo "$CHANGED_FILES"
          echo ""
          
          EMAILS_SENT=0
          EMAILS_SKIPPED=0
          
          # Process each changed file
          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi
            
            echo "Processing: $file"
            
            # Check if file exists in current commit
            if [ ! -f "$file" ]; then
              echo "  Skipping: File not found"
              echo ""
              EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
              continue
            fi
            
            # Determine if file is new or modified
            IS_NEW_FILE=$(git diff --name-only --diff-filter=A HEAD~1 HEAD | grep "^$file$" || true)
            
            # Extract current frontmatter and content
            CONTENT=$(cat "$file")
            
            # Check if file has frontmatter
            if ! echo "$CONTENT" | head -n 1 | grep -q "^+++"; then
              echo "  Skipping: No frontmatter found"
              echo ""
              EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
              continue
            fi
            
            # Extract frontmatter (between first and second +++)
            FRONTMATTER=$(echo "$CONTENT" | awk '/^\+\+\+$/{if(++n==2)exit;next}n')
            
            # Extract post content (after second +++)
            POST_CONTENT=$(echo "$CONTENT" | awk '/^\+\+\+$/{n++; next} n>=2')
            
            # Check current draft status
            CURRENT_IS_DRAFT=$(echo "$FRONTMATTER" | grep -i "^draft\s*=.*true" || true)
            
            # For modified files, check previous draft status
            PREVIOUS_IS_DRAFT=""
            if [ -z "$IS_NEW_FILE" ]; then
              # Get previous version of the file
              PREVIOUS_CONTENT=$(git show HEAD~1:"$file" 2>/dev/null || echo "")
              if [ -n "$PREVIOUS_CONTENT" ]; then
                PREVIOUS_FRONTMATTER=$(echo "$PREVIOUS_CONTENT" | awk '/^\+\+\+$/{if(++n==2)exit;next}n')
                PREVIOUS_IS_DRAFT=$(echo "$PREVIOUS_FRONTMATTER" | grep -i "^draft\s*=.*true" || true)
              fi
            fi
            
            # Determine what action to take
            SHOULD_SEND_PRODUCTION=false
            SHOULD_SEND_TEST=false
            
            if [ -n "$IS_NEW_FILE" ]; then
              # New file
              if [ -z "$CURRENT_IS_DRAFT" ]; then
                echo "  New post, not a draft - sending to production"
                SHOULD_SEND_PRODUCTION=true
              else
                echo "  New post, is a draft - sending to test segment"
                SHOULD_SEND_TEST=true
              fi
            else
              # Modified file
              if [ -n "$CURRENT_IS_DRAFT" ]; then
                # Currently a draft - send to test segment
                echo "  Draft updated - sending to test segment"
                SHOULD_SEND_TEST=true
              elif [ -n "$PREVIOUS_IS_DRAFT" ] && [ -z "$CURRENT_IS_DRAFT" ]; then
                # Was draft, now not draft - send to production
                echo "  Post transitioned from draft to published - sending to production"
                SHOULD_SEND_PRODUCTION=true
              elif [ -n "$REPUBLISH_FILES" ] && echo " $REPUBLISH_FILES " | grep -q " $(basename "$file") "; then
                # Was not draft, still not draft, but [[REPUBLISH files...]] flag matches - send to production
                echo "  [[REPUBLISH]] matches $(basename "$file") - sending updated published post to production"
                SHOULD_SEND_PRODUCTION=true
              else
                # Was not draft, still not draft - skip
                echo "  Skipping: Post already published (no email for updates to published posts)"
                echo ""
                EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
                continue
              fi
            fi
            
            if [ "$SHOULD_SEND_PRODUCTION" = false ] && [ "$SHOULD_SEND_TEST" = false ]; then
              echo "  Skipping: No action needed"
              echo ""
              EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
              continue
            fi
            
            # Extract title (handle both quoted and unquoted)
            TITLE=$(echo "$FRONTMATTER" | grep "^title\s*=" | head -n 1 | sed 's/^title\s*=\s*//' | sed 's/^"\(.*\)"$/\1/' | sed "s/^'\(.*\)'$/\1/")
            POST_SLUG=$(basename "$file" .md)
            POST_URL="https://viruus.zip/$POST_SLUG/"
            POST_DATE=$(echo "$FRONTMATTER" | grep "^date\s*=" | head -n 1 | sed 's/^date\s*=\s*//' | sed 's/^"\(.*\)"$/\1/' | sed "s/^'\(.*\)'$/\1/")
            POST_DATE_ISO="$POST_DATE"
            POST_DATE_DISPLAY=$(date -d "$POST_DATE" "+%d %b, %Y" 2>/dev/null || echo "$POST_DATE")
            if [ -z "$POST_DATE_DISPLAY" ]; then
              POST_DATE_DISPLAY="Unknown date"
              POST_DATE_ISO="Unknown date"
            fi
            
            if [ -z "$TITLE" ]; then
              TITLE="Untitled Post"
            fi
            
            echo "  Title: $TITLE"
            
            # Determine which segment to use
            if [ "$SHOULD_SEND_PRODUCTION" = true ]; then
              TARGET_SEGMENT_ID="$RESEND_SEGMENT_ID"
              EMAIL_TYPE="production"
            else
              TARGET_SEGMENT_ID="$RESEND_TEST_SEGMENT_ID"
              EMAIL_TYPE="test"
            fi
            
            echo "  Sending to: $EMAIL_TYPE segment"
            
            # Convert markdown to HTML using pandoc
            POST_HTML=$(echo "$POST_CONTENT" | pandoc -f markdown -t html)
            
            # Fix relative image paths to absolute URLs
            POST_HTML=$(echo "$POST_HTML" | sed 's|src="/images/|src="https://viruus.zip/images/|g')
            
            # Remove footnote anchor links (email clients don't handle anchors well)
            # Use perl with -0777 flag to handle multiline HTML properly
            
            # Remove footnote reference links like <a href="#fn1" ...><sup>1</sup></a> but keep the superscript number
            POST_HTML=$(echo "$POST_HTML" | perl -0777 -pe 's|<a[^>]*href="#fn\d+"[^>]*>(<sup>\d+</sup>)</a>|\1|gs')
            
            # Remove backlinks in footnotes (the ↩︎ links back to text)
            POST_HTML=$(echo "$POST_HTML" | perl -0777 -pe 's|<a[^>]*href="#fnref\d+"[^>]*>.*?</a>||gs')
            
            # Remove id attributes from footnote elements (so they're not anchor targets)
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| id="fn\d+"||g')
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| id="fnref\d+"||g')
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| id="footnotes"||g')
            
            # Remove role attributes that reference footnotes
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| role="doc-noteref"||g')
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| role="doc-backlink"||g')
            POST_HTML=$(echo "$POST_HTML" | perl -pe 's| role="doc-endnotes"||g')
            
            # Add simple header (date + canonical link) and unsubscribe footer
            HEADER_HTML="<p><i><time datetime=\"$POST_DATE_ISO\">$POST_DATE_DISPLAY</time> · <a href=\"$POST_URL\">Read on viruus.zip</a></i></p>"
            UNSUBSCRIBE_HTML="<p>If you no longer want these emails, <a href=\"{{{RESEND_UNSUBSCRIBE_URL}}}\">unsubscribe</a>.</p>"
            POST_HTML="${HEADER_HTML}${POST_HTML}${UNSUBSCRIBE_HTML}"
            
            # Escape content for JSON
            POST_HTML_ESCAPED=$(echo "$POST_HTML" | jq -Rs .)
            
            # Add draft indicator to subject for test emails
            if [ "$SHOULD_SEND_TEST" = true ]; then
              EMAIL_SUBJECT="[DRAFT] $TITLE"
            else
              EMAIL_SUBJECT="$TITLE"
            fi
            
            # Create JSON payload
            JSON_PAYLOAD=$(jq -n \
              --arg segment_id "$TARGET_SEGMENT_ID" \
              --arg from "dropalltables <blog@system.viruus.zip>" \
              --arg name "$TITLE" \
              --arg subject "$EMAIL_SUBJECT" \
              --argjson html "$POST_HTML_ESCAPED" \
              '{
                segment_id: $segment_id,
                from: $from,
                name: $name,
                subject: $subject,
                html: $html
              }')
            
            # Create broadcast via Resend API
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.resend.com/broadcasts" \
              -H "Authorization: Bearer $RESEND_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$JSON_PAYLOAD")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
            RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
              BROADCAST_ID=$(echo "$RESPONSE_BODY" | jq -r '.id // "unknown"')
              echo "  Broadcast created: $BROADCAST_ID"
              
              # Send the broadcast
              SEND_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.resend.com/broadcasts/$BROADCAST_ID/send" \
                -H "Authorization: Bearer $RESEND_API_KEY")
              
              SEND_HTTP_CODE=$(echo "$SEND_RESPONSE" | tail -n 1)
              
              if [ "$SEND_HTTP_CODE" = "200" ] || [ "$SEND_HTTP_CODE" = "201" ]; then
                echo "  Email sent successfully"
                EMAILS_SENT=$((EMAILS_SENT + 1))
              else
                SEND_RESPONSE_BODY=$(echo "$SEND_RESPONSE" | head -n -1)
                echo "  Error sending broadcast (HTTP $SEND_HTTP_CODE)"
                echo "  Response: $SEND_RESPONSE_BODY"
                EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
              fi
            else
              echo "  Error creating broadcast (HTTP $HTTP_CODE)"
              echo "  Response: $RESPONSE_BODY"
              EMAILS_SKIPPED=$((EMAILS_SKIPPED + 1))
            fi
            
            echo ""
          done <<< "$CHANGED_FILES"
          
          echo "Summary: $EMAILS_SENT email(s) sent, $EMAILS_SKIPPED skipped"
          exit 0
